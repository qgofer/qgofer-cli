{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"qgofer-cli \u00b6 All your documents are one quick search away. Documentation: https://qgofer.github.io/qgofer-cli GitHub: https://github.com/qgofer/qgofer-cli PyPI: https://pypi.org/project/qgofer/ Free software: MIT Usage : $ [ OPTIONS ] COMMAND [ ARGS ] ... Options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. --help : Show this message and exit. Commands : hello : About qgofer. wake-up : Initialize qgofer. hello \u00b6 About qgofer. Usage : $ hello [ OPTIONS ] Options : -v, --what-version : Show the current version of qgofer that has been installed. --help : Show this message and exit. wake-up \u00b6 Initialize qgofer. Usage : $ wake-up [ OPTIONS ] Options : -d, --home-dir TEXT : The user home directory to use for qgofer. -r, --root-dir TEXT : The root directory to start searching from. --help : Show this message and exit. Features \u00b6 TODO \u00b6 Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#qgofer-cli","text":"All your documents are one quick search away. Documentation: https://qgofer.github.io/qgofer-cli GitHub: https://github.com/qgofer/qgofer-cli PyPI: https://pypi.org/project/qgofer/ Free software: MIT Usage : $ [ OPTIONS ] COMMAND [ ARGS ] ... Options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. --help : Show this message and exit. Commands : hello : About qgofer. wake-up : Initialize qgofer.","title":"qgofer-cli"},{"location":"#hello","text":"About qgofer. Usage : $ hello [ OPTIONS ] Options : -v, --what-version : Show the current version of qgofer that has been installed. --help : Show this message and exit.","title":"hello"},{"location":"#wake-up","text":"Initialize qgofer. Usage : $ wake-up [ OPTIONS ] Options : -d, --home-dir TEXT : The user home directory to use for qgofer. -r, --root-dir TEXT : The root directory to start searching from. --help : Show this message and exit.","title":"wake-up"},{"location":"#features","text":"","title":"Features"},{"location":"#todo","text":"","title":"TODO"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Top-level package for qgofer. __main__ special \u00b6 qgofer - A command line tool for searching your files. main () \u00b6 Run the qgofer cli. Source code in qgofer/__main__.py def main (): \"\"\"Run the qgofer cli.\"\"\" cli . app ( prog_name = __app_name__ ) app \u00b6 Main module. App \u00b6 The main appliation class for managing the entirety of qgofer. Attributes: Name Type Description home The home directory of the user, defaults to Path.home() root_dir The root directory to index, defaults to Path.home() Source code in qgofer/app.py class App : \"\"\"The main appliation class for managing the entirety of qgofer. Attributes: home: The home directory of the user, defaults to Path.home() root_dir: The root directory to index, defaults to Path.home() \"\"\" __slots__ = ( \"_home\" , \"_root_dir\" , \"_qgofer\" , \"_qgofer_config\" , \"_qgofer_cache\" , \"_qgofer_cache_db\" , \"_qgofer_logs\" , ) _instances : Dict [ Any , Any ] = {} def __new__ ( cls , home , root_dir ) -> App : \"\"\"Create a new instance of the class. by using the singleton pattern.\"\"\" if cls not in cls . _instances : cls . _instances [ cls ] = super ( App , cls ) . __new__ ( cls ) return cls . _instances [ cls ] def __init__ ( self , home : Path = Path . home (), root_dir : Path = Path . home ()): \"\"\"Initialize the class. using home and root_dir as the home and root directory of qgofer.\"\"\" self . _home = home self . _root_dir = root_dir self . _qgofer = self . _home / '.qgofer' self . _qgofer . mkdir ( parents = True , exist_ok = True ) self . _qgofer_config = self . _qgofer / 'config.toml' self . _qgofer_config . touch ( exist_ok = True ) self . _qgofer_cache = self . _qgofer / 'cache' self . _qgofer_cache . mkdir ( parents = True , exist_ok = True ) self . _qgofer_cache_db = self . _qgofer_cache / 'qgofer.db' self . _qgofer_cache_db . touch ( exist_ok = True ) self . _qgofer_logs = self . _qgofer / 'logs' self . _qgofer_logs . mkdir ( parents = True , exist_ok = True ) @property def home ( self ) -> Path : \"\"\"Return the home directory of the user.\"\"\" return self . _home @property def qgofer ( self ) -> Path : \"\"\"Return the qgofer directory.\"\"\" return self . _qgofer @property def qgofer_config ( self ) -> Path : \"\"\"Return the qgofer config file.\"\"\" return self . _qgofer_config @property def qgofer_cache ( self ) -> Path : \"\"\"Return the qgofer cache directory.\"\"\" return self . _qgofer_cache @property def qgofer_cache_db ( self ) -> Path : \"\"\"Return the qgofer cache database.\"\"\" return self . _qgofer_cache_db def __repr__ ( self ) -> str : \"\"\"Return the representation of the class.\"\"\" return f \" { self . __class__ . __name__ } ( { self . home } )\" def __str__ ( self ) -> str : \"\"\"Return the string representation of the class.\"\"\" return \"Qgofer your personal assistant\" home : Path property readonly \u00b6 Return the home directory of the user. qgofer : Path property readonly \u00b6 Return the qgofer directory. qgofer_cache : Path property readonly \u00b6 Return the qgofer cache directory. qgofer_cache_db : Path property readonly \u00b6 Return the qgofer cache database. qgofer_config : Path property readonly \u00b6 Return the qgofer config file. __init__ ( self , home = PosixPath ( '/home/runner' ), root_dir = PosixPath ( '/home/runner' )) special \u00b6 Initialize the class. using home and root_dir as the home and root directory of qgofer. Source code in qgofer/app.py def __init__ ( self , home : Path = Path . home (), root_dir : Path = Path . home ()): \"\"\"Initialize the class. using home and root_dir as the home and root directory of qgofer.\"\"\" self . _home = home self . _root_dir = root_dir self . _qgofer = self . _home / '.qgofer' self . _qgofer . mkdir ( parents = True , exist_ok = True ) self . _qgofer_config = self . _qgofer / 'config.toml' self . _qgofer_config . touch ( exist_ok = True ) self . _qgofer_cache = self . _qgofer / 'cache' self . _qgofer_cache . mkdir ( parents = True , exist_ok = True ) self . _qgofer_cache_db = self . _qgofer_cache / 'qgofer.db' self . _qgofer_cache_db . touch ( exist_ok = True ) self . _qgofer_logs = self . _qgofer / 'logs' self . _qgofer_logs . mkdir ( parents = True , exist_ok = True ) __new__ ( cls , home , root_dir ) special staticmethod \u00b6 Create a new instance of the class. by using the singleton pattern. Source code in qgofer/app.py def __new__ ( cls , home , root_dir ) -> App : \"\"\"Create a new instance of the class. by using the singleton pattern.\"\"\" if cls not in cls . _instances : cls . _instances [ cls ] = super ( App , cls ) . __new__ ( cls ) return cls . _instances [ cls ] __repr__ ( self ) special \u00b6 Return the representation of the class. Source code in qgofer/app.py def __repr__ ( self ) -> str : \"\"\"Return the representation of the class.\"\"\" return f \" { self . __class__ . __name__ } ( { self . home } )\" __str__ ( self ) special \u00b6 Return the string representation of the class. Source code in qgofer/app.py def __str__ ( self ) -> str : \"\"\"Return the string representation of the class.\"\"\" return \"Qgofer your personal assistant\" create_index_list ( app ) \u00b6 Index the folders. Source code in qgofer/app.py def create_index_list ( app : App ) -> App : \"\"\"Index the folders.\"\"\" # A list to be populated with async tasks. for item in _index_folder ( app . _root_dir ): with open ( app . _qgofer_cache / \"inde_list.txt\" , \"a\" , encoding = \"utf-8\" ) as f : f . write ( f \" { item } \\n \" ) return app process_index_list ( app ) \u00b6 Process the index list. Source code in qgofer/app.py def process_index_list ( app : App ) -> App : \"\"\"Process the index list.\"\"\" async def _read_index_list ( app : App ) -> AsyncGenerator [ Path , None ]: \"\"\"Read the index list.\"\"\" async with aiofiles . open ( app . _qgofer_cache / \"inde_list.txt\" , \"r\" , encoding = \"utf-8\" ) as f : async for line in f : yield Path ( line . strip ()) async def _process_files ( app : App ) -> AsyncGenerator [ Tuple [ str , Path ], None ]: \"\"\"Process the index list.\"\"\" async for item in _read_index_list ( app ): async with aiofiles . open ( item , \"r\" , encoding = \"utf-8\" ) as f : content = await f . read () yield content , item async def _gen_meta ( app : App ) -> AsyncGenerator [ Tuple [ Any , float , float , Path ], None ]: \"\"\"Generate the meta data.\"\"\" async for content , file in _process_files ( app ): kw = rake . exec ( content ) m_time = os . path . getmtime ( file ) c_time = os . path . getctime ( file ) print ( kw , m_time , c_time , file ) yield kw , m_time , c_time , file async def _process_meta ( app : App ) -> None : \"\"\"Process the meta data.\"\"\" async for kw , m_time , c_time , file in _gen_meta ( app ): print ( kw , m_time , c_time , file ) async_run ( _process_meta ( app )) return app cli \u00b6 Console script for qgofer_cli. init ( home_dir =< typer . models . OptionInfo object at 0x7f52ff7e5610 > , root_dir =< typer . models . OptionInfo object at 0x7f52ff7e55e0 > ) \u00b6 Initialize qgofer. Source code in qgofer/cli.py @app . command ( \"wake-up\" ) def init ( home_dir = typer . Option ( None , \"--home-dir\" , \"-d\" , help = \"The user home directory to use for qgofer.\" , callback = init_path , ), root_dir = typer . Option ( None , \"--root-dir\" , \"-r\" , help = \"The root directory to start searching from.\" , callback = init_path ), ) -> None : \"\"\"Initialize qgofer.\"\"\" typer . echo ( \"Initializing qgofer...\" ) qgofer_app = App ( home_dir , root_dir ) qgofer_app = create_index_list ( qgofer_app ) qgofer_app = process_index_list ( qgofer_app ) return None main ( version =< typer . models . OptionInfo object at 0x7f52ff7e5580 > ) \u00b6 About qgofer. Source code in qgofer/cli.py @app . command ( \"hello\" ) def main ( version : Optional [ bool ] = typer . Option ( None , \"--what-version\" , \"-v\" , help = \"Show the current version of qgofer that has been installed.\" , callback = version_callback , is_eager = True , ) ) -> None : \"\"\"About qgofer.\"\"\" try : username = os . getlogin () except FileNotFoundError : username = \"You\" typer . echo ( f \"Hello { username } , I am Q, your assistant. \\n \" ) typer . echo ( f \"My model version is ' { __version__ } ' \\n \" ) description = __description__ . lower () typer . echo ( f \"With my help, { description } . \\n \" ) return None version_callback ( value ) \u00b6 Show the current version of qgofer that has been installed. Source code in qgofer/cli.py def version_callback ( value : bool ) -> None : \"\"\"Show the current version of qgofer that has been installed.\"\"\" if value : typer . echo ( f \" { __app_name__ } : v { __version__ } \\n \" ) raise typer . Exit () return None logger \u00b6 Logging module for qgofer. get_logger ( log_path = None , run_id = None ) \u00b6 Returns a generic logger for logging relevant information pertaining to run of qgofer. Returns: Type Description Logger Python logger object Source code in qgofer/logger.py def get_logger ( log_path = None , run_id = None ) -> logging . Logger : \"\"\"Returns a generic logger for logging relevant information pertaining to run of qgofer. Returns: Python logger object \"\"\" log_path = get_log_path ( log_path ) # create logger with 'spam_application' logger = logging . getLogger ( \"qgofer\" ) logger . setLevel ( logging . DEBUG ) if not run_id : run_id = generate_uuid () file_path = f \" { log_path } / { run_id } _log_ { datetime . datetime . now () . strftime ( '%y_%m_ %d _%H_%M_%S' ) } .log\" if not logger . handlers : # create file handler which logs even debug messages fh = logging . FileHandler ( file_path ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler ( stream = sys . stdout ) ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) logger . info ( f \"Logging to { file_path } \" ) return logger rake \u00b6 Rapid Automatic Keyword Extraction algorithm. RAKE \u00b6 Rapid Automatic Keyword Extraction algorithm. Source code in qgofer/rake.py class RAKE ( object ): \"\"\"Rapid Automatic Keyword Extraction algorithm.\"\"\" def __init__ ( self , stop_words_file : str = '' ): \"\"\"Initialize the RAKE object.\"\"\" self . stop_words_file_path = stop_words_file self . stop_words_pattern = build_stop_word_regex ( stop_words_file ) def exec ( self , text : str ): \"\"\"Execute the RAKE algorithm.\"\"\" sentences = self . split_sentences ( text ) phrases = self . generate_candidate_keywords ( sentences ) word_scores = self . calculate_word_scores ( phrases ) keyword_candidates = self . generate_candidate_keyword_scores ( phrases , word_scores ) sorted_keywords = sorted ( keyword_candidates . items (), key = operator . itemgetter ( 1 ), reverse = True ) return sorted_keywords def split_sentences ( self , text : str ) -> list : \"\"\"Split text into sentences.\"\"\" pattern = u '[.!?,;: \\t\\\\\\\\ \" \\\\ ( \\\\ ) \\\\\\'\\u2019\\u2013 ]| \\\\ s \\\\ - \\\\ s' sentence_delimiters = re . compile ( pattern ) sentences = sentence_delimiters . split ( text ) return sentences def generate_candidate_keywords ( self , sentences : list ) -> list : \"\"\"Returns keyword phrases after removing stopwords from each sentence.\"\"\" phrases_list = [] for sentence in sentences : phrases = re . sub ( self . stop_words_pattern , '|' , sentence . strip ()) . split ( '|' ) for phrase in phrases : phrase = phrase . strip () . lower () if phrase != \"\" : phrases_list . append ( phrase ) return phrases_list def is_number ( self , s ): \"\"\"Check if a string is a number.\"\"\" try : float ( s ) if '.' in s else int ( s ) return True except ValueError : return False def separate_words ( self , text : str , word_min_size : int = 0 ) -> list : \"\"\"Return a list of all words of length greater than specified min size. Args: text: the text that is to be split into words word_min_size: the min. no. of characters a word must have (def: 0) \"\"\" splitter = re . compile ( '[^a-zA-Z0-9_ \\\\ + \\\\ -/]' ) words = [] for single_word in splitter . split ( text ): current_word = single_word . strip () . lower () if len ( current_word ) > word_min_size and current_word != '' and not self . is_number ( current_word ): words . append ( current_word ) return words def calculate_word_scores ( self , phrases : list ) -> dict : \"\"\"Calculates the word score for all the words in the phrases.\"\"\" word_frequency : Dict [ Any , Any ] = {} word_degree : Dict [ Any , Any ] = {} for phrase in phrases : words = self . separate_words ( phrase ) words_list_degree = len ( words ) - 1 for word in words : word_frequency . setdefault ( word , 0 ) word_frequency [ word ] += 1 word_degree . setdefault ( word , 0 ) word_degree [ word ] += words_list_degree for item in word_frequency : word_degree [ item ] = word_degree [ item ] + word_frequency [ item ] # Calculate word score = def(w) / freq(w) word_score = {} for item in word_frequency : # word_score.setdefault(item, 0): word_score [ item ] = word_degree [ item ] / ( word_frequency [ item ] * 1.0 ) return word_score def generate_candidate_keyword_scores ( self , phrases : list , word_score : dict ) -> dict : \"\"\"Returns the dict. of candidate keywords with scores.\"\"\" keyword_candidates : Dict [ Any , Any ] = {} for phrase in phrases : keyword_candidates . setdefault ( phrase , 0 ) words = self . separate_words ( phrase ) candidate_score = 0 for word in words : candidate_score += word_score [ word ] keyword_candidates [ phrase ] = candidate_score return keyword_candidates __init__ ( self , stop_words_file = '' ) special \u00b6 Initialize the RAKE object. Source code in qgofer/rake.py def __init__ ( self , stop_words_file : str = '' ): \"\"\"Initialize the RAKE object.\"\"\" self . stop_words_file_path = stop_words_file self . stop_words_pattern = build_stop_word_regex ( stop_words_file ) calculate_word_scores ( self , phrases ) \u00b6 Calculates the word score for all the words in the phrases. Source code in qgofer/rake.py def calculate_word_scores ( self , phrases : list ) -> dict : \"\"\"Calculates the word score for all the words in the phrases.\"\"\" word_frequency : Dict [ Any , Any ] = {} word_degree : Dict [ Any , Any ] = {} for phrase in phrases : words = self . separate_words ( phrase ) words_list_degree = len ( words ) - 1 for word in words : word_frequency . setdefault ( word , 0 ) word_frequency [ word ] += 1 word_degree . setdefault ( word , 0 ) word_degree [ word ] += words_list_degree for item in word_frequency : word_degree [ item ] = word_degree [ item ] + word_frequency [ item ] # Calculate word score = def(w) / freq(w) word_score = {} for item in word_frequency : # word_score.setdefault(item, 0): word_score [ item ] = word_degree [ item ] / ( word_frequency [ item ] * 1.0 ) return word_score exec ( self , text ) \u00b6 Execute the RAKE algorithm. Source code in qgofer/rake.py def exec ( self , text : str ): \"\"\"Execute the RAKE algorithm.\"\"\" sentences = self . split_sentences ( text ) phrases = self . generate_candidate_keywords ( sentences ) word_scores = self . calculate_word_scores ( phrases ) keyword_candidates = self . generate_candidate_keyword_scores ( phrases , word_scores ) sorted_keywords = sorted ( keyword_candidates . items (), key = operator . itemgetter ( 1 ), reverse = True ) return sorted_keywords generate_candidate_keyword_scores ( self , phrases , word_score ) \u00b6 Returns the dict. of candidate keywords with scores. Source code in qgofer/rake.py def generate_candidate_keyword_scores ( self , phrases : list , word_score : dict ) -> dict : \"\"\"Returns the dict. of candidate keywords with scores.\"\"\" keyword_candidates : Dict [ Any , Any ] = {} for phrase in phrases : keyword_candidates . setdefault ( phrase , 0 ) words = self . separate_words ( phrase ) candidate_score = 0 for word in words : candidate_score += word_score [ word ] keyword_candidates [ phrase ] = candidate_score return keyword_candidates generate_candidate_keywords ( self , sentences ) \u00b6 Returns keyword phrases after removing stopwords from each sentence. Source code in qgofer/rake.py def generate_candidate_keywords ( self , sentences : list ) -> list : \"\"\"Returns keyword phrases after removing stopwords from each sentence.\"\"\" phrases_list = [] for sentence in sentences : phrases = re . sub ( self . stop_words_pattern , '|' , sentence . strip ()) . split ( '|' ) for phrase in phrases : phrase = phrase . strip () . lower () if phrase != \"\" : phrases_list . append ( phrase ) return phrases_list is_number ( self , s ) \u00b6 Check if a string is a number. Source code in qgofer/rake.py def is_number ( self , s ): \"\"\"Check if a string is a number.\"\"\" try : float ( s ) if '.' in s else int ( s ) return True except ValueError : return False separate_words ( self , text , word_min_size = 0 ) \u00b6 Return a list of all words of length greater than specified min size. Parameters: Name Type Description Default text str the text that is to be split into words required word_min_size int the min. no. of characters a word must have (def: 0) 0 Source code in qgofer/rake.py def separate_words ( self , text : str , word_min_size : int = 0 ) -> list : \"\"\"Return a list of all words of length greater than specified min size. Args: text: the text that is to be split into words word_min_size: the min. no. of characters a word must have (def: 0) \"\"\" splitter = re . compile ( '[^a-zA-Z0-9_ \\\\ + \\\\ -/]' ) words = [] for single_word in splitter . split ( text ): current_word = single_word . strip () . lower () if len ( current_word ) > word_min_size and current_word != '' and not self . is_number ( current_word ): words . append ( current_word ) return words split_sentences ( self , text ) \u00b6 Split text into sentences. Source code in qgofer/rake.py def split_sentences ( self , text : str ) -> list : \"\"\"Split text into sentences.\"\"\" pattern = u '[.!?,;: \\t\\\\\\\\ \" \\\\ ( \\\\ ) \\\\\\'\\u2019\\u2013 ]| \\\\ s \\\\ - \\\\ s' sentence_delimiters = re . compile ( pattern ) sentences = sentence_delimiters . split ( text ) return sentences build_stop_word_regex ( stop_words_file_path ) \u00b6 Builds a regex expression to match any of the stop word. Parameters: Name Type Description Default stop_words_file_path str filepath of a file containing stop words required Source code in qgofer/rake.py def build_stop_word_regex ( stop_words_file_path : str ) -> re . Pattern : \"\"\"Builds a regex expression to match any of the stop word. Args: stop_words_file_path: filepath of a file containing stop words \"\"\" if stop_words_file_path : stop_words_list = load_stop_words ( stop_words_file_path ) else : stop_words_list = stop_words stop_words_regex_list = [] for word in stop_words_list : word_regex = r '\\b' + word + r '(?![\\w-])' stop_words_regex_list . append ( word_regex ) stop_words_pattern = re . compile ( '|' . join ( stop_words_regex_list ), re . IGNORECASE ) return stop_words_pattern load_stop_words ( stop_words_file_path ) \u00b6 Loads stop words from a file and return as a list of words. Parameters: Name Type Description Default stop_words_file_path str filepath of a file containing stop words required Source code in qgofer/rake.py def load_stop_words ( stop_words_file_path : str ) -> list : \"\"\"Loads stop words from a file and return as a list of words. Args: stop_words_file_path: filepath of a file containing stop words \"\"\" stop_words = [] file = open ( stop_words_file_path ) for line in file : if line . strip ()[ 0 : 1 ] != \"#\" : for word in line . split (): # in case more than one per line stop_words . append ( word ) file . close () return stop_words utils \u00b6 Utility functions for qgofer. generate_uuid () \u00b6 Generates a uuid 4 string, in this context for tracking each run of the experiment. Returns: Type Description str an ascii friendly uuid4 string. Source code in qgofer/utils.py def generate_uuid () -> str : \"\"\"Generates a uuid 4 string, in this context for tracking each run of the experiment. Returns: an ascii friendly uuid4 string. \"\"\" return base64 . urlsafe_b64encode ( uuid . uuid4 () . bytes ) . rstrip ( b \"=\" ) . decode ( \"ascii\" ) get_log_path ( path = None ) \u00b6 Returns the log path. Source code in qgofer/utils.py def get_log_path ( path : Optional [ Path ] = None ) -> Path : \"\"\"Returns the log path.\"\"\" if path is None : path = init_path ( path ) / '.qgofer' / 'logs' path . mkdir ( parents = True , exist_ok = True ) return Path ( path ) . expanduser () . resolve () init_path ( path = None ) \u00b6 Convert the string to a path object. Source code in qgofer/utils.py def init_path ( path : Optional [ Path ] = None ) -> Path : \"\"\"Convert the string to a path object.\"\"\" if path is None : return Path . home () return Path ( path ) . expanduser () . resolve ()","title":"Modules"},{"location":"api/#qgofer.__main__","text":"qgofer - A command line tool for searching your files.","title":"__main__"},{"location":"api/#qgofer.__main__.main","text":"Run the qgofer cli. Source code in qgofer/__main__.py def main (): \"\"\"Run the qgofer cli.\"\"\" cli . app ( prog_name = __app_name__ )","title":"main()"},{"location":"api/#qgofer.app","text":"Main module.","title":"app"},{"location":"api/#qgofer.app.App","text":"The main appliation class for managing the entirety of qgofer. Attributes: Name Type Description home The home directory of the user, defaults to Path.home() root_dir The root directory to index, defaults to Path.home() Source code in qgofer/app.py class App : \"\"\"The main appliation class for managing the entirety of qgofer. Attributes: home: The home directory of the user, defaults to Path.home() root_dir: The root directory to index, defaults to Path.home() \"\"\" __slots__ = ( \"_home\" , \"_root_dir\" , \"_qgofer\" , \"_qgofer_config\" , \"_qgofer_cache\" , \"_qgofer_cache_db\" , \"_qgofer_logs\" , ) _instances : Dict [ Any , Any ] = {} def __new__ ( cls , home , root_dir ) -> App : \"\"\"Create a new instance of the class. by using the singleton pattern.\"\"\" if cls not in cls . _instances : cls . _instances [ cls ] = super ( App , cls ) . __new__ ( cls ) return cls . _instances [ cls ] def __init__ ( self , home : Path = Path . home (), root_dir : Path = Path . home ()): \"\"\"Initialize the class. using home and root_dir as the home and root directory of qgofer.\"\"\" self . _home = home self . _root_dir = root_dir self . _qgofer = self . _home / '.qgofer' self . _qgofer . mkdir ( parents = True , exist_ok = True ) self . _qgofer_config = self . _qgofer / 'config.toml' self . _qgofer_config . touch ( exist_ok = True ) self . _qgofer_cache = self . _qgofer / 'cache' self . _qgofer_cache . mkdir ( parents = True , exist_ok = True ) self . _qgofer_cache_db = self . _qgofer_cache / 'qgofer.db' self . _qgofer_cache_db . touch ( exist_ok = True ) self . _qgofer_logs = self . _qgofer / 'logs' self . _qgofer_logs . mkdir ( parents = True , exist_ok = True ) @property def home ( self ) -> Path : \"\"\"Return the home directory of the user.\"\"\" return self . _home @property def qgofer ( self ) -> Path : \"\"\"Return the qgofer directory.\"\"\" return self . _qgofer @property def qgofer_config ( self ) -> Path : \"\"\"Return the qgofer config file.\"\"\" return self . _qgofer_config @property def qgofer_cache ( self ) -> Path : \"\"\"Return the qgofer cache directory.\"\"\" return self . _qgofer_cache @property def qgofer_cache_db ( self ) -> Path : \"\"\"Return the qgofer cache database.\"\"\" return self . _qgofer_cache_db def __repr__ ( self ) -> str : \"\"\"Return the representation of the class.\"\"\" return f \" { self . __class__ . __name__ } ( { self . home } )\" def __str__ ( self ) -> str : \"\"\"Return the string representation of the class.\"\"\" return \"Qgofer your personal assistant\"","title":"App"},{"location":"api/#qgofer.app.App.home","text":"Return the home directory of the user.","title":"home"},{"location":"api/#qgofer.app.App.qgofer","text":"Return the qgofer directory.","title":"qgofer"},{"location":"api/#qgofer.app.App.qgofer_cache","text":"Return the qgofer cache directory.","title":"qgofer_cache"},{"location":"api/#qgofer.app.App.qgofer_cache_db","text":"Return the qgofer cache database.","title":"qgofer_cache_db"},{"location":"api/#qgofer.app.App.qgofer_config","text":"Return the qgofer config file.","title":"qgofer_config"},{"location":"api/#qgofer.app.App.__init__","text":"Initialize the class. using home and root_dir as the home and root directory of qgofer. Source code in qgofer/app.py def __init__ ( self , home : Path = Path . home (), root_dir : Path = Path . home ()): \"\"\"Initialize the class. using home and root_dir as the home and root directory of qgofer.\"\"\" self . _home = home self . _root_dir = root_dir self . _qgofer = self . _home / '.qgofer' self . _qgofer . mkdir ( parents = True , exist_ok = True ) self . _qgofer_config = self . _qgofer / 'config.toml' self . _qgofer_config . touch ( exist_ok = True ) self . _qgofer_cache = self . _qgofer / 'cache' self . _qgofer_cache . mkdir ( parents = True , exist_ok = True ) self . _qgofer_cache_db = self . _qgofer_cache / 'qgofer.db' self . _qgofer_cache_db . touch ( exist_ok = True ) self . _qgofer_logs = self . _qgofer / 'logs' self . _qgofer_logs . mkdir ( parents = True , exist_ok = True )","title":"__init__()"},{"location":"api/#qgofer.app.App.__new__","text":"Create a new instance of the class. by using the singleton pattern. Source code in qgofer/app.py def __new__ ( cls , home , root_dir ) -> App : \"\"\"Create a new instance of the class. by using the singleton pattern.\"\"\" if cls not in cls . _instances : cls . _instances [ cls ] = super ( App , cls ) . __new__ ( cls ) return cls . _instances [ cls ]","title":"__new__()"},{"location":"api/#qgofer.app.App.__repr__","text":"Return the representation of the class. Source code in qgofer/app.py def __repr__ ( self ) -> str : \"\"\"Return the representation of the class.\"\"\" return f \" { self . __class__ . __name__ } ( { self . home } )\"","title":"__repr__()"},{"location":"api/#qgofer.app.App.__str__","text":"Return the string representation of the class. Source code in qgofer/app.py def __str__ ( self ) -> str : \"\"\"Return the string representation of the class.\"\"\" return \"Qgofer your personal assistant\"","title":"__str__()"},{"location":"api/#qgofer.app.create_index_list","text":"Index the folders. Source code in qgofer/app.py def create_index_list ( app : App ) -> App : \"\"\"Index the folders.\"\"\" # A list to be populated with async tasks. for item in _index_folder ( app . _root_dir ): with open ( app . _qgofer_cache / \"inde_list.txt\" , \"a\" , encoding = \"utf-8\" ) as f : f . write ( f \" { item } \\n \" ) return app","title":"create_index_list()"},{"location":"api/#qgofer.app.process_index_list","text":"Process the index list. Source code in qgofer/app.py def process_index_list ( app : App ) -> App : \"\"\"Process the index list.\"\"\" async def _read_index_list ( app : App ) -> AsyncGenerator [ Path , None ]: \"\"\"Read the index list.\"\"\" async with aiofiles . open ( app . _qgofer_cache / \"inde_list.txt\" , \"r\" , encoding = \"utf-8\" ) as f : async for line in f : yield Path ( line . strip ()) async def _process_files ( app : App ) -> AsyncGenerator [ Tuple [ str , Path ], None ]: \"\"\"Process the index list.\"\"\" async for item in _read_index_list ( app ): async with aiofiles . open ( item , \"r\" , encoding = \"utf-8\" ) as f : content = await f . read () yield content , item async def _gen_meta ( app : App ) -> AsyncGenerator [ Tuple [ Any , float , float , Path ], None ]: \"\"\"Generate the meta data.\"\"\" async for content , file in _process_files ( app ): kw = rake . exec ( content ) m_time = os . path . getmtime ( file ) c_time = os . path . getctime ( file ) print ( kw , m_time , c_time , file ) yield kw , m_time , c_time , file async def _process_meta ( app : App ) -> None : \"\"\"Process the meta data.\"\"\" async for kw , m_time , c_time , file in _gen_meta ( app ): print ( kw , m_time , c_time , file ) async_run ( _process_meta ( app )) return app","title":"process_index_list()"},{"location":"api/#qgofer.cli","text":"Console script for qgofer_cli.","title":"cli"},{"location":"api/#qgofer.cli.init","text":"Initialize qgofer. Source code in qgofer/cli.py @app . command ( \"wake-up\" ) def init ( home_dir = typer . Option ( None , \"--home-dir\" , \"-d\" , help = \"The user home directory to use for qgofer.\" , callback = init_path , ), root_dir = typer . Option ( None , \"--root-dir\" , \"-r\" , help = \"The root directory to start searching from.\" , callback = init_path ), ) -> None : \"\"\"Initialize qgofer.\"\"\" typer . echo ( \"Initializing qgofer...\" ) qgofer_app = App ( home_dir , root_dir ) qgofer_app = create_index_list ( qgofer_app ) qgofer_app = process_index_list ( qgofer_app ) return None","title":"init()"},{"location":"api/#qgofer.cli.main","text":"About qgofer. Source code in qgofer/cli.py @app . command ( \"hello\" ) def main ( version : Optional [ bool ] = typer . Option ( None , \"--what-version\" , \"-v\" , help = \"Show the current version of qgofer that has been installed.\" , callback = version_callback , is_eager = True , ) ) -> None : \"\"\"About qgofer.\"\"\" try : username = os . getlogin () except FileNotFoundError : username = \"You\" typer . echo ( f \"Hello { username } , I am Q, your assistant. \\n \" ) typer . echo ( f \"My model version is ' { __version__ } ' \\n \" ) description = __description__ . lower () typer . echo ( f \"With my help, { description } . \\n \" ) return None","title":"main()"},{"location":"api/#qgofer.cli.version_callback","text":"Show the current version of qgofer that has been installed. Source code in qgofer/cli.py def version_callback ( value : bool ) -> None : \"\"\"Show the current version of qgofer that has been installed.\"\"\" if value : typer . echo ( f \" { __app_name__ } : v { __version__ } \\n \" ) raise typer . Exit () return None","title":"version_callback()"},{"location":"api/#qgofer.logger","text":"Logging module for qgofer.","title":"logger"},{"location":"api/#qgofer.logger.get_logger","text":"Returns a generic logger for logging relevant information pertaining to run of qgofer. Returns: Type Description Logger Python logger object Source code in qgofer/logger.py def get_logger ( log_path = None , run_id = None ) -> logging . Logger : \"\"\"Returns a generic logger for logging relevant information pertaining to run of qgofer. Returns: Python logger object \"\"\" log_path = get_log_path ( log_path ) # create logger with 'spam_application' logger = logging . getLogger ( \"qgofer\" ) logger . setLevel ( logging . DEBUG ) if not run_id : run_id = generate_uuid () file_path = f \" { log_path } / { run_id } _log_ { datetime . datetime . now () . strftime ( '%y_%m_ %d _%H_%M_%S' ) } .log\" if not logger . handlers : # create file handler which logs even debug messages fh = logging . FileHandler ( file_path ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler ( stream = sys . stdout ) ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) logger . info ( f \"Logging to { file_path } \" ) return logger","title":"get_logger()"},{"location":"api/#qgofer.rake","text":"Rapid Automatic Keyword Extraction algorithm.","title":"rake"},{"location":"api/#qgofer.rake.RAKE","text":"Rapid Automatic Keyword Extraction algorithm. Source code in qgofer/rake.py class RAKE ( object ): \"\"\"Rapid Automatic Keyword Extraction algorithm.\"\"\" def __init__ ( self , stop_words_file : str = '' ): \"\"\"Initialize the RAKE object.\"\"\" self . stop_words_file_path = stop_words_file self . stop_words_pattern = build_stop_word_regex ( stop_words_file ) def exec ( self , text : str ): \"\"\"Execute the RAKE algorithm.\"\"\" sentences = self . split_sentences ( text ) phrases = self . generate_candidate_keywords ( sentences ) word_scores = self . calculate_word_scores ( phrases ) keyword_candidates = self . generate_candidate_keyword_scores ( phrases , word_scores ) sorted_keywords = sorted ( keyword_candidates . items (), key = operator . itemgetter ( 1 ), reverse = True ) return sorted_keywords def split_sentences ( self , text : str ) -> list : \"\"\"Split text into sentences.\"\"\" pattern = u '[.!?,;: \\t\\\\\\\\ \" \\\\ ( \\\\ ) \\\\\\'\\u2019\\u2013 ]| \\\\ s \\\\ - \\\\ s' sentence_delimiters = re . compile ( pattern ) sentences = sentence_delimiters . split ( text ) return sentences def generate_candidate_keywords ( self , sentences : list ) -> list : \"\"\"Returns keyword phrases after removing stopwords from each sentence.\"\"\" phrases_list = [] for sentence in sentences : phrases = re . sub ( self . stop_words_pattern , '|' , sentence . strip ()) . split ( '|' ) for phrase in phrases : phrase = phrase . strip () . lower () if phrase != \"\" : phrases_list . append ( phrase ) return phrases_list def is_number ( self , s ): \"\"\"Check if a string is a number.\"\"\" try : float ( s ) if '.' in s else int ( s ) return True except ValueError : return False def separate_words ( self , text : str , word_min_size : int = 0 ) -> list : \"\"\"Return a list of all words of length greater than specified min size. Args: text: the text that is to be split into words word_min_size: the min. no. of characters a word must have (def: 0) \"\"\" splitter = re . compile ( '[^a-zA-Z0-9_ \\\\ + \\\\ -/]' ) words = [] for single_word in splitter . split ( text ): current_word = single_word . strip () . lower () if len ( current_word ) > word_min_size and current_word != '' and not self . is_number ( current_word ): words . append ( current_word ) return words def calculate_word_scores ( self , phrases : list ) -> dict : \"\"\"Calculates the word score for all the words in the phrases.\"\"\" word_frequency : Dict [ Any , Any ] = {} word_degree : Dict [ Any , Any ] = {} for phrase in phrases : words = self . separate_words ( phrase ) words_list_degree = len ( words ) - 1 for word in words : word_frequency . setdefault ( word , 0 ) word_frequency [ word ] += 1 word_degree . setdefault ( word , 0 ) word_degree [ word ] += words_list_degree for item in word_frequency : word_degree [ item ] = word_degree [ item ] + word_frequency [ item ] # Calculate word score = def(w) / freq(w) word_score = {} for item in word_frequency : # word_score.setdefault(item, 0): word_score [ item ] = word_degree [ item ] / ( word_frequency [ item ] * 1.0 ) return word_score def generate_candidate_keyword_scores ( self , phrases : list , word_score : dict ) -> dict : \"\"\"Returns the dict. of candidate keywords with scores.\"\"\" keyword_candidates : Dict [ Any , Any ] = {} for phrase in phrases : keyword_candidates . setdefault ( phrase , 0 ) words = self . separate_words ( phrase ) candidate_score = 0 for word in words : candidate_score += word_score [ word ] keyword_candidates [ phrase ] = candidate_score return keyword_candidates","title":"RAKE"},{"location":"api/#qgofer.rake.RAKE.__init__","text":"Initialize the RAKE object. Source code in qgofer/rake.py def __init__ ( self , stop_words_file : str = '' ): \"\"\"Initialize the RAKE object.\"\"\" self . stop_words_file_path = stop_words_file self . stop_words_pattern = build_stop_word_regex ( stop_words_file )","title":"__init__()"},{"location":"api/#qgofer.rake.RAKE.calculate_word_scores","text":"Calculates the word score for all the words in the phrases. Source code in qgofer/rake.py def calculate_word_scores ( self , phrases : list ) -> dict : \"\"\"Calculates the word score for all the words in the phrases.\"\"\" word_frequency : Dict [ Any , Any ] = {} word_degree : Dict [ Any , Any ] = {} for phrase in phrases : words = self . separate_words ( phrase ) words_list_degree = len ( words ) - 1 for word in words : word_frequency . setdefault ( word , 0 ) word_frequency [ word ] += 1 word_degree . setdefault ( word , 0 ) word_degree [ word ] += words_list_degree for item in word_frequency : word_degree [ item ] = word_degree [ item ] + word_frequency [ item ] # Calculate word score = def(w) / freq(w) word_score = {} for item in word_frequency : # word_score.setdefault(item, 0): word_score [ item ] = word_degree [ item ] / ( word_frequency [ item ] * 1.0 ) return word_score","title":"calculate_word_scores()"},{"location":"api/#qgofer.rake.RAKE.exec","text":"Execute the RAKE algorithm. Source code in qgofer/rake.py def exec ( self , text : str ): \"\"\"Execute the RAKE algorithm.\"\"\" sentences = self . split_sentences ( text ) phrases = self . generate_candidate_keywords ( sentences ) word_scores = self . calculate_word_scores ( phrases ) keyword_candidates = self . generate_candidate_keyword_scores ( phrases , word_scores ) sorted_keywords = sorted ( keyword_candidates . items (), key = operator . itemgetter ( 1 ), reverse = True ) return sorted_keywords","title":"exec()"},{"location":"api/#qgofer.rake.RAKE.generate_candidate_keyword_scores","text":"Returns the dict. of candidate keywords with scores. Source code in qgofer/rake.py def generate_candidate_keyword_scores ( self , phrases : list , word_score : dict ) -> dict : \"\"\"Returns the dict. of candidate keywords with scores.\"\"\" keyword_candidates : Dict [ Any , Any ] = {} for phrase in phrases : keyword_candidates . setdefault ( phrase , 0 ) words = self . separate_words ( phrase ) candidate_score = 0 for word in words : candidate_score += word_score [ word ] keyword_candidates [ phrase ] = candidate_score return keyword_candidates","title":"generate_candidate_keyword_scores()"},{"location":"api/#qgofer.rake.RAKE.generate_candidate_keywords","text":"Returns keyword phrases after removing stopwords from each sentence. Source code in qgofer/rake.py def generate_candidate_keywords ( self , sentences : list ) -> list : \"\"\"Returns keyword phrases after removing stopwords from each sentence.\"\"\" phrases_list = [] for sentence in sentences : phrases = re . sub ( self . stop_words_pattern , '|' , sentence . strip ()) . split ( '|' ) for phrase in phrases : phrase = phrase . strip () . lower () if phrase != \"\" : phrases_list . append ( phrase ) return phrases_list","title":"generate_candidate_keywords()"},{"location":"api/#qgofer.rake.RAKE.is_number","text":"Check if a string is a number. Source code in qgofer/rake.py def is_number ( self , s ): \"\"\"Check if a string is a number.\"\"\" try : float ( s ) if '.' in s else int ( s ) return True except ValueError : return False","title":"is_number()"},{"location":"api/#qgofer.rake.RAKE.separate_words","text":"Return a list of all words of length greater than specified min size. Parameters: Name Type Description Default text str the text that is to be split into words required word_min_size int the min. no. of characters a word must have (def: 0) 0 Source code in qgofer/rake.py def separate_words ( self , text : str , word_min_size : int = 0 ) -> list : \"\"\"Return a list of all words of length greater than specified min size. Args: text: the text that is to be split into words word_min_size: the min. no. of characters a word must have (def: 0) \"\"\" splitter = re . compile ( '[^a-zA-Z0-9_ \\\\ + \\\\ -/]' ) words = [] for single_word in splitter . split ( text ): current_word = single_word . strip () . lower () if len ( current_word ) > word_min_size and current_word != '' and not self . is_number ( current_word ): words . append ( current_word ) return words","title":"separate_words()"},{"location":"api/#qgofer.rake.RAKE.split_sentences","text":"Split text into sentences. Source code in qgofer/rake.py def split_sentences ( self , text : str ) -> list : \"\"\"Split text into sentences.\"\"\" pattern = u '[.!?,;: \\t\\\\\\\\ \" \\\\ ( \\\\ ) \\\\\\'\\u2019\\u2013 ]| \\\\ s \\\\ - \\\\ s' sentence_delimiters = re . compile ( pattern ) sentences = sentence_delimiters . split ( text ) return sentences","title":"split_sentences()"},{"location":"api/#qgofer.rake.build_stop_word_regex","text":"Builds a regex expression to match any of the stop word. Parameters: Name Type Description Default stop_words_file_path str filepath of a file containing stop words required Source code in qgofer/rake.py def build_stop_word_regex ( stop_words_file_path : str ) -> re . Pattern : \"\"\"Builds a regex expression to match any of the stop word. Args: stop_words_file_path: filepath of a file containing stop words \"\"\" if stop_words_file_path : stop_words_list = load_stop_words ( stop_words_file_path ) else : stop_words_list = stop_words stop_words_regex_list = [] for word in stop_words_list : word_regex = r '\\b' + word + r '(?![\\w-])' stop_words_regex_list . append ( word_regex ) stop_words_pattern = re . compile ( '|' . join ( stop_words_regex_list ), re . IGNORECASE ) return stop_words_pattern","title":"build_stop_word_regex()"},{"location":"api/#qgofer.rake.load_stop_words","text":"Loads stop words from a file and return as a list of words. Parameters: Name Type Description Default stop_words_file_path str filepath of a file containing stop words required Source code in qgofer/rake.py def load_stop_words ( stop_words_file_path : str ) -> list : \"\"\"Loads stop words from a file and return as a list of words. Args: stop_words_file_path: filepath of a file containing stop words \"\"\" stop_words = [] file = open ( stop_words_file_path ) for line in file : if line . strip ()[ 0 : 1 ] != \"#\" : for word in line . split (): # in case more than one per line stop_words . append ( word ) file . close () return stop_words","title":"load_stop_words()"},{"location":"api/#qgofer.utils","text":"Utility functions for qgofer.","title":"utils"},{"location":"api/#qgofer.utils.generate_uuid","text":"Generates a uuid 4 string, in this context for tracking each run of the experiment. Returns: Type Description str an ascii friendly uuid4 string. Source code in qgofer/utils.py def generate_uuid () -> str : \"\"\"Generates a uuid 4 string, in this context for tracking each run of the experiment. Returns: an ascii friendly uuid4 string. \"\"\" return base64 . urlsafe_b64encode ( uuid . uuid4 () . bytes ) . rstrip ( b \"=\" ) . decode ( \"ascii\" )","title":"generate_uuid()"},{"location":"api/#qgofer.utils.get_log_path","text":"Returns the log path. Source code in qgofer/utils.py def get_log_path ( path : Optional [ Path ] = None ) -> Path : \"\"\"Returns the log path.\"\"\" if path is None : path = init_path ( path ) / '.qgofer' / 'logs' path . mkdir ( parents = True , exist_ok = True ) return Path ( path ) . expanduser () . resolve ()","title":"get_log_path()"},{"location":"api/#qgofer.utils.init_path","text":"Convert the string to a path object. Source code in qgofer/utils.py def init_path ( path : Optional [ Path ] = None ) -> Path : \"\"\"Convert the string to a path object.\"\"\" if path is None : return Path . home () return Path ( path ) . expanduser () . resolve ()","title":"init_path()"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] \u00b6 [0.0.2] - 2013-02-25 \u00b6 Added \u00b6 First release on PyPI. Initial project setup.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#002---2013-02-25","text":"","title":"[0.0.2] - 2013-02-25"},{"location":"changelog/#added","text":"First release on PyPI. Initial project setup.","title":"Added"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/qgofer/qgofer-cli/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 qgofer-cli could always use more documentation, whether as part of the official qgofer-cli docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/qgofer/qgofer-cli/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up qgofer-cli for local development. Fork the qgofer-cli repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/qgofer-cli.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/qgofer/qgofer-cli/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_qgofer_cli.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/qgofer/qgofer-cli/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"qgofer-cli could always use more documentation, whether as part of the official qgofer-cli docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/qgofer/qgofer-cli/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up qgofer-cli for local development. Fork the qgofer-cli repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/qgofer-cli.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/qgofer/qgofer-cli/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_qgofer_cli.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install qgofer-cli, run this command in your terminal: $ pip install qgofer-cli This is the preferred method to install qgofer-cli, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for qgofer-cli can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/qgofer/qgofer-cli Or download the tarball : $ curl -OJL https://github.com/qgofer/qgofer-cli/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install qgofer-cli, run this command in your terminal: $ pip install qgofer-cli This is the preferred method to install qgofer-cli, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for qgofer-cli can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/qgofer/qgofer-cli Or download the tarball : $ curl -OJL https://github.com/qgofer/qgofer-cli/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use qgofer-cli in a project import qgofer_cli","title":"Usage"},{"location":"usage/#usage","text":"To use qgofer-cli in a project import qgofer_cli","title":"Usage"}]}